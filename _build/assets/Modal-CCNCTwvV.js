import{$ as _,f as ne,I as G,J,b as K,t as h,w as b,u as ie,a as le,j as U,q as Y,K as oe,A as L,d as ae,L as de,z as q,G as ue,F as ce}from"./web-B1e86Evu.js";const B=Symbol("store-raw"),S=Symbol("store-node"),p=Symbol("store-has"),Q=Symbol("store-self");function ee(r){let e=r[_];if(!e&&(Object.defineProperty(r,_,{value:e=new Proxy(r,pe)}),!Array.isArray(r))){const t=Object.keys(r),s=Object.getOwnPropertyDescriptors(r);for(let n=0,i=t.length;n<i;n++){const l=t[n];s[l].get&&Object.defineProperty(r,l,{enumerable:s[l].enumerable,get:s[l].get.bind(e)})}}return e}function O(r){let e;return r!=null&&typeof r=="object"&&(r[_]||!(e=Object.getPrototypeOf(r))||e===Object.prototype||Array.isArray(r))}function R(r,e=new Set){let t,s,n,i;if(t=r!=null&&r[B])return t;if(!O(r)||e.has(r))return r;if(Array.isArray(r)){Object.isFrozen(r)?r=r.slice(0):e.add(r);for(let l=0,a=r.length;l<a;l++)n=r[l],(s=R(n,e))!==n&&(r[l]=s)}else{Object.isFrozen(r)?r=Object.assign({},r):e.add(r);const l=Object.keys(r),a=Object.getOwnPropertyDescriptors(r);for(let o=0,d=l.length;o<d;o++)i=l[o],!a[i].get&&(n=r[i],(s=R(n,e))!==n&&(r[i]=s))}return r}function C(r,e){let t=r[e];return t||Object.defineProperty(r,e,{value:t=Object.create(null)}),t}function v(r,e,t){if(r[e])return r[e];const[s,n]=K(t,{equals:!1,internal:!0});return s.$=n,r[e]=s}function he(r,e){const t=Reflect.getOwnPropertyDescriptor(r,e);return!t||t.get||!t.configurable||e===_||e===S||(delete t.value,delete t.writable,t.get=()=>r[_][e]),t}function te(r){J()&&v(C(r,S),Q)()}function be(r){return te(r),Reflect.ownKeys(r)}const pe={get(r,e,t){if(e===B)return r;if(e===_)return t;if(e===G)return te(r),t;const s=C(r,S),n=s[e];let i=n?n():r[e];if(e===S||e===p||e==="__proto__")return i;if(!n){const l=Object.getOwnPropertyDescriptor(r,e);J()&&(typeof i!="function"||r.hasOwnProperty(e))&&!(l&&l.get)&&(i=v(s,e,i)())}return O(i)?ee(i):i},has(r,e){return e===B||e===_||e===G||e===S||e===p||e==="__proto__"?!0:(J()&&v(C(r,p),e)(),e in r)},set(){return!0},deleteProperty(){return!0},ownKeys:be,getOwnPropertyDescriptor:he};function P(r,e,t,s=!1){if(!s&&r[e]===t)return;const n=r[e],i=r.length;t===void 0?(delete r[e],r[p]&&r[p][e]&&n!==void 0&&r[p][e].$()):(r[e]=t,r[p]&&r[p][e]&&n===void 0&&r[p][e].$());let l=C(r,S),a;if((a=v(l,e,n))&&a.$(()=>t),Array.isArray(r)&&r.length!==i){for(let o=r.length;o<i;o++)(a=l[o])&&a.$();(a=v(l,"length",i))&&a.$(r.length)}(a=l[Q])&&a.$()}function re(r,e){const t=Object.keys(e);for(let s=0;s<t.length;s+=1){const n=t[s];P(r,n,e[n])}}function me(r,e){if(typeof e=="function"&&(e=e(r)),e=R(e),Array.isArray(e)){if(r===e)return;let t=0,s=e.length;for(;t<s;t++){const n=e[t];r[t]!==n&&P(r,t,n)}P(r,"length",s)}else re(r,e)}function A(r,e,t=[]){let s,n=r;if(e.length>1){s=e.shift();const l=typeof s,a=Array.isArray(r);if(Array.isArray(s)){for(let o=0;o<s.length;o++)A(r,[s[o]].concat(e),t);return}else if(a&&l==="function"){for(let o=0;o<r.length;o++)s(r[o],o)&&A(r,[o].concat(e),t);return}else if(a&&l==="object"){const{from:o=0,to:d=r.length-1,by:f=1}=s;for(let g=o;g<=d;g+=f)A(r,[g].concat(e),t);return}else if(e.length>1){A(r[s],e,[s].concat(t));return}n=r[s],t=[s].concat(t)}let i=e[0];typeof i=="function"&&(i=i(n,t),i===n)||s===void 0&&i==null||(i=R(i),s===void 0||O(n)&&O(i)&&!Array.isArray(i)?re(n,i):P(r,s,i))}function N(...[r,e]){const t=R(r||{}),s=Array.isArray(t),n=ee(t);function i(...l){ne(()=>{s&&l.length===1?me(t,l[0]):A(t,l)})}return[n,i]}var fe=b('<div class=hlx-header><div class=hlx-title><p class=hlx-title-text>HelixAsm</p><a href=https://github.com/NullRoz007/HelixAsm/tree/main><i class="nes-icon github"></i></a></div><p class=hlx-desc>The Helix Assembly Language is an assembly language designed to make producing code for my custom 8bit Minecraft CPU easier.');function Ye(){return h(fe)}const ge=["INT","OP","REG","MEM","EOF","KWD","LBL","ESR","ROUTE"],ye=["CL","LD","PP","PO","JZ","JP","RT","RI","AD","SB","AN","OR","NO","XO","SL","SR"],W=r=>{let e=parseInt(r);return!isNaN(e)&&Number.isInteger(e)};class we{constructor(e){this.expression=e.replaceAll(" ",""),this.pos=0}advance(){this.pos+=1}getNextToken(){if(this.pos>=this.expression.length)return new m("EOF",null);let e=this.expression[this.pos];if(W(e)){let t="";for(;W(e);)t+=e,this.advance(),e=this.expression[this.pos];return new m("INT",parseInt(t))}return this.advance(),new m("OP",e)}tokenize(){let e=[],t=this.getNextToken();for(;t.type!=="EOF";)e.push(t),t=this.getNextToken();return e.push(new m("EOF",null)),e}}class _e{constructor(e){this.tokens=e,this.pos=0,this.precedence={"+":10,"-":10,"*":20,"/":20}}peek(){return this.tokens[this.pos]}next(){return this.tokens[this.pos++]}lbp(e){return e.type=="OP"&&this.precedence[e.value]||0}nud(e){if(e.type=="INT")return{type:"atom",value:e.value};if(e.type=="OP"&&e.value=="("){let t=this.parseExpression(0);return this.next(),t}throw new Error("Unexpected token in nud: "+e.value)}led(e,t){if(t.type=="OP"){let s=this.parseExpression(this.lbp(t));return{type:"expr",op:t.value,left:e,right:s}}throw new Error("Unexpected token in led: "+t.value)}parseExpression(e=0){let t=this.next(),s=this.nud(t);for(;e<this.lbp(this.peek());){let n=this.next();s=this.led(s,n)}return s}parse(){return this.parseExpression(0)}}const z=r=>{if(r.type=="atom")return r.value;if(r.type=="expr"){let e=z(r.left),t=z(r.right);switch(r.op){case"+":return e+t;case"-":return e-t;case"*":return e*t;case"/":return e/t;default:throw new Error("Error evalulating AST!")}}},xe=r=>{const t=new we(r).tokenize(),n=new _e(t).parse();return z(n)},X=50,I=r=>{let e=parseInt(r);return!isNaN(e)&&Number.isInteger(e)},Se=r=>"@abcdefghijklmnopqrstuvwxyz".indexOf(r.toLowerCase())!=-1;class m{constructor(e=null,t=null){this.type=e,this.value=t}}class $e{constructor(e){this.src=e.trim(),this.tokens={},this.keywords=ye,this.pos=0,this.expressions=[],this.subroutines={};for(let t of ge)this.tokens[t]=s=>new m(t,s)}getAddress(){let e="",t=this.src[this.pos+1];for(;I(t);)e+=t,this.advance(),t=this.src[this.pos+1];return parseInt(e)}getMacro(){let e="",t=this.src[this.pos+1],s=X,n=0;for(;t!=";";)if(e+=t,this.advance(),t=this.src[this.pos+1],n++,n>s)throw new Error(`Max expression length (${X}) exceeded. Did you forget a ';'?
${e}`);return e}getSubroutine(){let e=new m,t=[];for(;e.type!="ESR"&&(e=this.getNextToken(),!!e);)e.type!=null&&t.push(e);return t.splice(0,t.length-1)}getLabel(e){return this.labels.map(t=>t.name==e)[0]||null}advance(e=1){this.pos+=e}getNextToken(){let e=new m,t=this.src[this.pos];if(t==" "||t==`
`)return this.advance(),e;if(this.pos>this.src.length-1)e=this.tokens.EOF(null);else if(I(t)){let s="";for(;I(t);)s+=t,t=this.src[this.pos+1],this.advance();e=this.tokens.INT(parseInt(s))}else if(t==":"||t=="#"){let s=this.getAddress();e=t==":"?this.tokens.REG(s):this.tokens.MEM(s)}else if(t=="@"){let s="";for(;Se(t)&&(t=this.src[this.pos+1],!(t==" "||t==";"));)s+=t,this.advance();const n=this.getMacro().trim();switch(s){case"expr":let i=xe(n);this.expressions.push({expr:n,value:i}),e=this.tokens.INT(i);break;case"label":e=this.tokens.LBL(n);break;case"start":this.advance(2);let l=this.getSubroutine();this.subroutines[n]=l;break;case"route":e=this.tokens.ROUTE(n);break;case"end":return e=this.tokens.ESR(null),e;default:throw new Error(`Unknown Macro Type: ${s}`)}this.advance(2)}else{let s="";for(;t!=" "&&(s+=t,!(this.pos+1>=this.src.length||(t=this.src[this.pos+1],s=="RT")));)this.advance();if(this.keywords.indexOf(s)!=-1)e=this.tokens.KWD(s);else throw e=null,new Error(`Unknown Keyword: ${s}`)}return this.advance(),e}tokenize(){let e=new m,t=[];for(;e.type!="EOF"&&(e=this.getNextToken(),!!e);)e.type!=null&&t.push(e);return t}}const D={AD:1,SB:2,AN:3,OR:4,NO:5,XO:6,OVERRIDE:7},E={PP:0,PO:0,JZ:115,JP:255,RT:223,RI:239,SL:24,SR:20,CL:227},c=(r,e)=>{let t="";for(let s=0;s<r;s++)t+="0";return t+=e,"0b"+t.slice(-r)};class Ae{constructor(e,t){this.name=e,this.pos=t}}class Re{constructor(e,t,s){this.name=e,this.pos=t,this.instructions=s}}class j{constructor(e=""){this.line=e,this.srName=null,this.srTableFlag=!1,this.memAddr=0,this.immValue=0,this.immFlag=0,this.aluCtrl=0,this.regAddr=0,this.writeFlag=0,this.clearFlag=0}setRaw(e,t){c(8,e.toString(2)),c(8,t.toString(2)),this.immValue=e,this.memAddr=e,this.immFlag=e&1,this.aluCtrl=t>>5&7,this.regAddr=t>>2&7,this.writeFlag=t>>1&1,this.clearFlag=t&1}build(){let e=0;if(e|=this.aluCtrl<<5,e|=this.regAddr<<2,e|=this.writeFlag<<1,e|=this.clearFlag,this.srTableFlag||this.srName)return[c(8,this.memAddr.toString(2)),c(8,e.toString(2))];let t=(this.immFlag?this.immValue:this.memAddr)<<1|this.immFlag;return[c(8,t.toString(2)),c(8,e.toString(2))]}toString(){let e=this.build(),t=`Line:		${this.line}
Instruction:	`,s=c(7,this.immValue.toString(2)),n=c(7,this.memAddr.toString(2)),i=c(3,this.aluCtrl.toString(2)),l=c(3,this.regAddr.toString(2));return t+=this.immFlag?`Imm(${s})`:`MemAddr(${n})`,t+=`, AluCtrl(${i})`,t+=`, RegAddr(${l})`,t+=`, Flags(imm = 0b${this.immFlag}, wr = 0b${this.writeFlag}, cl = 0b${this.clearFlag})`,t+=`
Raw:		[${e[0]}, ${e[1]}]`,t}}class Z{constructor(e,t){this.tokens=e,this.pos=0,this.instructions=[],this.labels=[],this.subroutines=t,this.loadedSubroutes=[]}lookAhead(e=1){let t=[],s=this.pos+1;if(this.pos+e<this.tokens.length)for(let n=0;n<e;n++){let i=this.tokens[s+n];t.push(i)}return t}advance(e=1){this.pos+=e}parseLoadKeyword(e,t,s){if(s=="INT")e.immFlag=1,e.aluCtrl=D.OVERRIDE,e.immValue=t;else if(s=="REG")e.immFlag=0,e.regAddr=t;else if(s=="MEM")e.immFlag=0,e.memAddr=t;else throw new Error(`Unsupported valueType!"
        value:	${t}
        type: 	${s}
      `)}parseKeyword(e){let t=new j,s=this.lookAhead(2),n=s[0].value,i=s[0].type,l=s[1].value,a=s[1].type,o=`${e.value}: `,d=null;if(i=="REG")t.regAddr=n;else if(i=="MEM")t.memAddr=n;else if(i=="LBL"){if(d=this.getLabel(n),!d)throw new Error(`Unknown label: ${n}`)}else if(i=="ROUTE"){if(!this.getSubroutine(n))throw new Error(`Unknown subroutine: ${n}`);t.srName=n}else if(i!="INT")throw new Error(`Unsupported addressType: ${i}`);if(D[e.value]!==void 0)o+=`${i}(${n})`,t.aluCtrl=D[e.value],this.advance();else if(E[e.value]!==void 0)o+=`${i}(${n}) - S`,i=="LBL"&&d&&(n=d.pos),t.setRaw(n,E[e.value]),this.advance();else if(e.value=="LD")o+=`${i}(${n}) <- ${a}(${l})`,this.parseLoadKeyword(t,l,a),t.writeFlag=1,this.advance(2);else throw new Error(`Unknown Keyword: '${e.value}'`);return t.line=o,t}getLabel(e){return this.labels.filter(t=>t.name==e)[0]}getSubroutine(e){return this.subroutines[e]}getNextToken(){return this.tokens[this.pos]}parse(){let e=new m,t=0;for(;e.type!="EOF"&&(e=this.getNextToken(),e!==void 0);){if(e.type=="KWD"){if(e.value=="RT"){let s=new j;s.setRaw(0,E.RT),s.line="RT: PC <- CALLSTACK.pop()",this.instructions.push(s),this.advance(),t++;continue}if(e.value=="CL"){let s=this.parseKeyword(e);this.instructions.push(s),this.advance(),t++;continue}}switch(e.type){case"KWD":let s=this.parseKeyword(e);this.instructions.push(s),this.advance(),t++;break;case"LBL":let n=e.value;this.getLabel(n)||this.labels.push(new Ae(n,t)),this.advance();break;case"EOF":break;default:throw new Error(`Unknown Token Type: ${e.type}`)}}}mapSubroutines(){let t=this.instructions.length;const s=[];for(let i in this.subroutines){let l=new Re(i,t,this.subroutines[i]);t+=l.instructions.length,s.push(l)}let n=new j;n.line="=== START SR_TABLE ===",n.srTableFlag=!0,n.setRaw(t+1,E.JP),this.instructions.push(n);for(let i of s)this.instructions.push(...i.instructions);for(let i of this.instructions)if(i.srName!==null){let l=s.filter(a=>a.name==i.srName)[0];i.memAddr=l.pos+1}}}const ve={IO_MAP:[],SCREEN_X:110,SCREEN_Y:96,SCREEN_CTRL:108,STACK_PTR:0,STACK_DEPTH:16};class Te{constructor(e){this.instructions=e,this.output={header:ve,instructions:[],lines:[]}}async build(e){for(let s of this.instructions)this.output.instructions.push(s.build()),this.output.lines.push(s.toString());return JSON.stringify(this.output,null,2)}}const se=le(),ke=()=>ie(se);function qe(r){const[e,t]=K(r.initialSource??""),[s,n]=K(""),[i,l]=N({editorOpen:!1,referenceOpen:!1}),[a,o]=N({parse:!1,error:!1,errorText:""}),[d,f]=N({tokens:[],instructions:[],expressions:[],labels:[]}),g=()=>{const u=new $e(e()),y=u.tokenize(),x=u.subroutines;let $={};for(let T of Object.keys(x)){let M=x[T],k=new Z(M,$);k.parse(),$[T]=k.instructions}const w=new Z(y,$);return w.parse(),w.mapSubroutines(),{parserResult:w,lexerResult:u}},F={source:e,setSource:t,buildOutput:s,setBuildOutput:n,ui:i,setUI:l,modal:a,setModal:o,report:d,setReport:f,testProgram:()=>{try{let{parserResult:u,lexerResult:y}=g();f({tokens:y.tokens,instructions:u.instructions,labels:u.labels,expressions:y.expressions}),o({parse:!0})}catch(u){o({error:!0,errorText:u.message})}},buildProgram:async()=>{try{let{parserResult:u}=g(),x=await new Te(u.instructions).build();n(x)}catch(u){o({error:!0,errorText:u.message})}}};return t(r.initialSrc),U(se.Provider,{value:F,get children(){return r.children}})}var Ee=b("<div id=editor><ul role=menu-bar><li role=menu-item tabindex=0 aria-haspopup=true>File<ul role=menu><li role=menu-item><button>Save Source</button></li><li role=menu-item><button>Save Build</button></li><li role=menu-item><button>Load</button></li></ul></li><li role=menu-item tabindex=1 aria-haspopup=true>Test<ul role=menu><li role=menu-item><button>Parse</button></li></ul></li><li role=menu-item tabindex=2 aria-haspopup=true>Build<ul role=menu><li role=menu-item><button>Json</button></li><li role=menu-item><button>Binary</button></li></ul></li></ul><div style=display:flex;width:100%><textarea></textarea><div class=buildOutput><pre>");function Qe(){const{source:r,setSource:e,testProgram:t,buildProgram:s,buildOutput:n}=ke();return(()=>{var i=h(Ee),l=i.firstChild,a=l.firstChild,o=a.nextSibling,d=o.firstChild,f=d.nextSibling,g=f.firstChild,V=g.firstChild,H=o.nextSibling,F=H.firstChild,u=F.nextSibling,y=u.firstChild,x=y.nextSibling,$=l.nextSibling,w=$.firstChild,T=w.nextSibling,M=T.firstChild;return V.$$click=()=>{t()},oe(y,"click",s,!0),x.$$click=()=>{},w.$$input=k=>{e(k.currentTarget.value)},L(M,n),ae(()=>de(w,"value",r())),q(),i})()}Y(["click","input"]);var Le=b("<details><summary>Instruction Format</summary><section><p>Every instruction has the form:</p><pre><code>KEYWORD target value</code></pre><h3>Target</h3><p>The destination written by the instruction:</p><table class=table-striped><thead><tr><th>Syntax</th><th>Meaning</th></tr></thead><tbody><tr><td>:n</td><td>Register n</td></tr><tr><td>#n</td><td>Memory cell n</td></tr></tbody></table><h3>Value</h3><p>The data written into the target:</p><table class=table-striped><thead><tr><th>Syntax</th><th>Meaning</th></tr></thead><tbody><tr><td>:n</td><td>Value from register n</td></tr><tr><td>#n</td><td>Value from memory cell n</td></tr><tr><td>n</td><td>Immediate literal</td></tr><tr><td>@expr &lt;expr&gt;</td><td>Expression evaluated at assembly time; result used as an immediate value</td></tr></tbody></table><p>Values without <code>:</code>, <code>#</code>, or <code>@expr</code> are treated as immediate integers.");function Oe(){return h(Le)}const Ce=Object.freeze(Object.defineProperty({__proto__:null,default:Oe},Symbol.toStringTag,{value:"Module"}));var Pe=b(`<details><summary>LD — Load</summary><section><pre><code>LD target value</code></pre><p>Writes the given value into the target register or memory cell.</p><p><strong>Examples:</strong></p><pre><code>
LD :1 10            ; Immediate 10 → R1
LD #3 :1            ; R1 → Memory 3
LD :0 #7            ; Memory 7 → R0
LD :4 @expr 12 + 8  ; Immediate 20 → R4`);function Fe(){return h(Pe)}const Me=Object.freeze(Object.defineProperty({__proto__:null,default:Fe},Symbol.toStringTag,{value:"Module"}));var Ne=b("<details><summary>JP — Jump</summary><section><pre><code>JP @label name;</code></pre><p>Unconditional jump to the instruction at a label.</p><p>Labels are declared using:</p><pre><code>@label name;</code></pre><p>Labels refer to instruction addresses.");function Ie(){return h(Ne)}const De=Object.freeze(Object.defineProperty({__proto__:null,default:Ie},Symbol.toStringTag,{value:"Module"}));var je=b("<details><summary>JZ — Jump if Zero</summary><section><pre><code>JZ @label name;</code></pre><p>Conditional jump to the instruction at a label. If <code>R0 == 0</code></p><p>The Helix CPU stores the result of ALU operations in R0.");function Je(){return h(je)}const Ke=Object.freeze(Object.defineProperty({__proto__:null,default:Je},Symbol.toStringTag,{value:"Module"}));var Ue=b(`<details><summary>Using Subroutines</summary><section><p>Subroutines are declared with the <code>@start name;</code> macro and closed using the <code>@end;</code> macro. They are invoked using the<code>CL</code> instrunction + the <code>@route name;</code> macro.</p><p>Subroutine instructions are removed from the main program flow and appended to the<strong> SR_TABLE</strong>. Subroutines must end with an <code>RT</code> instruction to return execution to the caller.</p><h3>Example</h3><pre><code>@label start;
LD :0 1

@start sub2;
LD :0 3
RT
@end;

@start sub1;
LD :0 2
CL @route sub2;
RT
@end;

CL @route sub1;
JP @label start;</code></pre><p>After execution, register <code>R0</code> will contain <strong>1</strong>.</p><p>The following table shows the final memory layout after subroutines are extracted into the SR_TABLE. Line <strong>3</strong> marks the automatically inserted table boundary.</p><h3>Final Program Structure in Memory</h3><table class=table-striped style=font-size:10px><thead><tr><th>Addr</th><th>Line</th><th>Instruction Fields</th><th>Raw</th><th>Notes</th></tr></thead><tbody><tr><td>0</td><td>LD: REG(0) ← INT(1)</td><td>Imm(0b0000001), AluCtrl(0b111), RegAddr(0b000),<br>Flags(imm=1, wr=1, cl=0)</td><td>[0b00000011, 0b11100010]</td><td></td></tr><tr><td>1</td><td>CL: ROUTE(sub1) - S</td><td>MemAddr(0b0000110), AluCtrl(0b111), RegAddr(0b000),<br>Flags(imm=0, wr=1, cl=1)</td><td>[0b00000110, 0b11100011]</td><td></td></tr><tr><td>2</td><td>JP: LBL(start) - S</td><td>MemAddr(0b0000000), AluCtrl(0b111), RegAddr(0b111),<br>Flags(imm=0, wr=1, cl=1)</td><td>[0b00000000, 0b11111111]</td><td></td></tr><tr><td>3</td><td>=== START SR_TABLE ===</td><td>MemAddr(0b0001001), AluCtrl(0b111), RegAddr(0b111),<br>Flags(imm=0, wr=1, cl=1)</td><td>[0b00001001, 0b11111111]</td><td>(a JP is used to avoid executing SR_TABLE automatically)</td></tr><tr><td colspan=5><strong>(sub2 @ line 4)</strong></td></tr><tr><td>4</td><td>LD: REG(0) ← INT(3)</td><td>Imm(0b0000011), AluCtrl(0b111), RegAddr(0b000),<br>Flags(imm=1, wr=1, cl=0)</td><td>[0b00000111, 0b11100010]</td><td></td></tr><tr><td>5</td><td>RT: PC ← CALLSTACK.pop()</td><td>MemAddr(0b0000000), AluCtrl(0b110), RegAddr(0b111),<br>Flags(imm=0, wr=1, cl=1)</td><td>[0b00000000, 0b11011111]</td><td>(return to sub1 @ line 8)</td></tr><tr><td colspan=5><strong>(sub1 @ line 6)</strong></td></tr><tr><td>6</td><td>LD: REG(0) ← INT(2)</td><td>Imm(0b0000010), AluCtrl(0b111), RegAddr(0b000),<br>Flags(imm=1, wr=1, cl=0)</td><td>[0b00000101, 0b11100010]</td><td></td></tr><tr><td>7</td><td>CL: ROUTE(sub2) - S</td><td>MemAddr(0b0000100), AluCtrl(0b111), RegAddr(0b000),<br>Flags(imm=0, wr=1, cl=1)</td><td>[0b00000100, 0b11100011]</td><td></td></tr><tr><td>8</td><td>RT: PC ← CALLSTACK.pop()</td><td>MemAddr(0b0000000), AluCtrl(0b110), RegAddr(0b111),<br>Flags(imm=0, wr=1, cl=1)</td><td>[0b00000000, 0b11011111]</td><td>`);function Be(){return h(Ue)}const ze=Object.freeze(Object.defineProperty({__proto__:null,default:Be},Symbol.toStringTag,{value:"Module"}));var Ve=b(`<details><summary>Example Program Explained</summary><section><h3>start</h3><pre><code>
@label start;
LD :1 0
LD #110 :1
LD #97 :1
LD #108 :1</code></pre><p>This example loads:</p><ul><li>Immediate 0 → R1</li><li>R1 → Memory 110</li><li>R1 → Memory 97</li><li>R1 → Memory 108</li></ul><h3>blink</h3><pre><code>
@label blink;
LD :1 @expr 30 + 1  ; Immediate 31 → R1
LD #110 :1           ; R1 → Memory 110
LD :1 1              ; Immediate 1 → R1
LD #108 :1           ; R1 → Memory 108
LD :1 0              ; Immediate 0 → R1
LD #108 :1           ; R1 → Memory 108
JP @label blink;     ; Jump back to blink</code></pre><p>This section blinks a pixel by repeatedly setting the Video Control Byte to 0x1/0x0</p><p>Except for the expression-based load, all values written to <code>:1</code> are immediates or copied to memory as shown.`);function He(){return h(Ve)}const Ge=Object.freeze(Object.defineProperty({__proto__:null,default:He},Symbol.toStringTag,{value:"Module"}));var We=b("<div>");function et(){const e=Object.values(Object.assign({"./references/0_Format.jsx":Ce,"./references/1_Load.jsx":Me,"./references/2_Jump.jsx":De,"./references/3_JumpCondtional.jsx":Ke,"./references/4_Subroutines.jsx":ze,"./references/5_ExampleProg.jsx":Ge})).map(t=>t.default);return(()=>{var t=h(We);return L(t,U(ue,{each:e,children:s=>U(s,{})})),t})()}var Xe=b('<div class=modal-overlay><div class="standard-dialog center scale-down"id=error-modal><div class=modal-contents><h1 class=modal-text></h1><!$><!/><section id=modal-row-btn class=field-row style=justify-content:flex-end><button class=btn>OK');function tt(r){return(()=>{var e=h(Xe),t=e.firstChild,s=t.firstChild,n=s.firstChild,i=n.nextSibling,[l,a]=ce(i.nextSibling),o=l.nextSibling,d=o.firstChild;return e.$$click=()=>r.onClose(),t.$$click=f=>f.stopPropagation(),L(n,()=>r.title),L(s,()=>r.children,l,a),d.$$click=()=>r.onClose(),q(),e})()}Y(["click"]);export{qe as C,Qe as E,Ye as H,tt as M,et as R,ke as u};
